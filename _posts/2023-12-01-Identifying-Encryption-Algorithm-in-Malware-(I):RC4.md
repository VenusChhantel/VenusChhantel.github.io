---
layout:	post
title:  "Identifying Encryption Algorithm in Malware (I):RC4"
date:   2023-12-01 11:11:11 +0200
categories: [Series - Identifying Encryption Algorithm in Malware]
tags: [Encryption Algorithms]
---

## Background

Encryption serves as a sophisticated mechanism employing algorithms to convert plaintext into ciphertext, establishing as a stalwart guardian to safeguard sensitive information from unauthorized access. Yet, in the intricate game of cat and mouse between defenders and adversaries, encryption has also found an unwelcome application in the realm of malware.

Malware leverage encryption algorithm for anti-defense and anti-analysis. There are two approaches that malware author can take to leverage encryption, which are:

-   Using APIs
-   Coding encryption algorithms

<br>

In case of samples using API for encryption, it can be easily identified because Microsoft has documented most of those APIs.

- [Wincrypt.h](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/)
- [bcrypt.h](https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptencrypt)

<br>

**Example**

Consider a sample that has functionality to decrypt obfuscated strings during run time. And for this, it uses  **CryptGenKey**  API from  **WinCrypt**  to generate cryptographic key, which handle will be passed to  **CryptDecrypt** to decrypt those obfuscated strings.

Following the  [Microsoft documentation on **CryptGenKey**](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt)  as shown below, the second parameter it takes is Algorithm ID.

![](https://miro.medium.com/v2/resize:fit:230/1*slusAiaM4Wb6MEnLP6xLeg.png)

By checking the  [value of Algorithm ID](https://learn.microsoft.com/en-us/windows/win32/seccrypto/alg-id)  that is passed as second parameter to the  **CryptGenKey**  API, the encryption algorithm can be identified easily.

![](https://miro.medium.com/v2/resize:fit:700/1*huoSR-GMqXuQKQUqhe2egg.png)

The usage of API made it easier to detect. But what if malware author codes cryptographic algorithm?

In such cases, malware analyst needs to understand the flow of cryptographic algorithm in order to identify them. So, this blog series will focus on identifying such algorithms. This first blog of this series will start with RC4.

<br>

## RC4 (Rivest Cipher 4)

RC4 is symmetric stream cipher developed by Ronald Rivest in 1987. It is one of the most encountered cryptographic algorithms in malware because of its simplicity and efficiency. It is widely used by malware for activities like:

-   To encrypt network communication to its C2.
-   To decrypt obfuscated strings and 2nd stager binary.

<br>


### Stages

RC4 algorithm consist of 3 stages:

#### KSA (Key Scheduling Algorithm)

-   In this phase, a 256-byte array substitution box is first initialized.
-   Then, using the key, the initialized substitution box is scrambled.

***Code:***

    def KSA(key):  
        SBox = list(range(0,256))                        # Initialize SBox with 256 values  
        j = 0  
        for i in range (0,256):  
            j = (j + SBox[i] + key[i % len(key)]) % 256  #SBox is scrambled with key  
            SBox[i],SBox[j] = SBox[j],SBox[i]            #Swap SBox[i] and SBox[j]  
        return SBox 

<br>

#### PRGA (Pseudo Random Generation Algorithm)

-   In this phase, the scrambled substitution box created in KSA stage is used to generate keystream.

***Code:***

    def PRGA(SBox):  
    i = 0  
    j = 0  
    while True:  
        i = (i + 1) % 256                        
        j = (j + SBox[i]) % 256  
        SBox[i],SBox[j] = SBox[j],SBox[i]      #Swap SBox[i] and SBox[j]  
        yield SBox[(SBox[i] + SBox[j]) % 256]  #Returns key stream generator

<br>

#### XOR

-   In this phase, each byte of plaintext/ciphertext is XOR with each byte of key stream generated in previous PRGA stage.

***Code:***

    def XOR(keyStream):  
        bufferCipher = ''  
        for c in plainText:  
            bufferCipher += "%02X" % (ord(c) ^ next(keyStream)) #XOR each byte of key stream with each byte of plaintext/cipher  
        return bufferCipher

<br>

The main function of the RC4 python code is shown below.

    key = [ord(c) for c in "SecretKey"]  
    plainText = 'C2 Network Communications'  
    cipherText = ''  
      
    SBox = KSA(key)  
    keyStream = PRGA(SBox)  
    cipherText = XOR(keyStream)  
    print(cipherText)

<br>

### Indicator:

The RC4 algorithm flow is easy to recognize.

-   The loops for 256 iterations are dead giveaway of RC4.

**Note:**  Tools like CAPA and KANAL can help to identify the possible cryptographic algorithm used in the sample.

<br>

## **CASE STUDY: RACCOON STEALER v2**

**MD5:**  0cfa58846e43dd67b6d9f29e97f6c53e

<br>

**NOTE:** I have changed the functions and variables name in both IDA and x32dbg to make it easier to understand. If you analyze this sample, you will find gibberish functions and variables name.

<br>

The Raccoon stealer v2 had employed RC4 algorithm to decrypt its strings and C2. Let's analyze this in IDA as shown in image below.

![](https://miro.medium.com/v2/resize:fit:649/1*kqeOxv9QxZgurHAVLCdJDg.png)

Here, RC4_decrypt function will decrypt the strings using RC4 algorithm.

-   The 2nd parameter passed are the obfuscated strings, which are decoded from base64 just a step above.
-   The 3rd parameter is the reference to v109 variable that stores the length of decoded base64 text (will be clear during debugging).
-   The 4th parameter passed is the key for RC4 encryption, which is ‘edinayarossiya’.

<br>

Under RC4_decrypt function as shown below, is **KSA**  stage:

![](https://miro.medium.com/v2/resize:fit:700/1*qfGFP54FokT3CZzrxko0rA.png)

-   First, there is do-while loop where a substitution box is initialized.
-   Then, under for loop, the initialized substitution box is scrambled with the key.
-   The other phases of RC4 are under sub_40869D.

<br>

Under the function sub_40869D, there were other phases of RC4, i.e., **PRGA**  and  **XOR**  as shown below.

![](https://miro.medium.com/v2/resize:fit:700/1*1eWZSKCwZflosaOzkbfG4A.png)

The for loop will iterate till the length of cipher text (a3).

-   In the PRGA phase, a key stream is generated from the scrambled substitution box, which each byte is XOR with each byte of cipher text.

<br>

Let's now debug this sample in x32dbg. The part where the obfuscated strings are passed to base64_decode function and rc4_decrypt function can be seen below.

![](https://miro.medium.com/v2/resize:fit:700/1*-g3z92owhjB3QSbw6-QLwQ.png)

<br>

For now, let's take an example of one obfuscated string ‘fVQMox8c’. First the string will be passed to base64_decode function that will decode it and return the value address in eax register. And the decoded text when checked in dump was found to be ‘}T.£..’ as shown below.

![](https://miro.medium.com/v2/resize:fit:700/1*ggxCARdV7r8nrSk082lQbQ.png)

Then, before the call to rc4_decrypt function at offset 002C405F, it pushes 3 values, which are:

1.  **Key**

-   The ‘_push edi_’ instruction pushes the key ‘edinayarossiya’ to the stack. Although passed at first, it is the last parameter of the rc4_decrypt because of little endian.

![](https://miro.medium.com/v2/resize:fit:700/1*a9qks-tT7S5dLk9q2PwKuw.png)

2. **Length of Base64 decoded text**

-   Next is ‘_push ecx_**’** instruction which pushes the length of the cipher text that was decoded from the previous function base64_decode, which is 6.

![](https://miro.medium.com/v2/resize:fit:700/1*nYrDwPXrC6C1i0mIrf6CvQ.png)

3.  **Base64 decoded text**

-   Then, there is ‘_push eax_**’** instruction which pushes the cipher text that was decoded from the previous function base64_decode, which is ‘}T.£..’ as shown below.

![](https://miro.medium.com/v2/resize:fit:700/1*OjHIfgA_2yUyu_tOk3KzGw.png)

After passing those values, the rc4_decrypt function will be called.

<br>

Let's dive into rc4_decrypt function. Under the function, the part responsible for initializing substitution box can be seen as shown below. This is the do-while loop that was seen in IDA.

![](https://miro.medium.com/v2/resize:fit:700/1*5ymhqx44QlBpOR4oHojXPg.png)

It will loop till the ecx register (counter) is less than 100h (256). And at each iteration, the ecx value will increase by 4. During this the substitution box is initialized, which can be seen in the Dump as shown above.

<br>

After that, there is another loop which will scramble the substitution box with the key as shown below. This is the do-while loop that was seen in IDA.

![](https://miro.medium.com/v2/resize:fit:700/1*EdiRoSgmXMCnYQB1jBeerQ.png)

It will loop till the ebx register is less than 100h (256). During which the previously initialized substitution box is scrambled as seen in the Dump as shown above. Above completing scrambling substitution box, there is call to 2C869D function as well.

<br>

Under 2C869D function, there is PRGA and XOR stages as shown in image below, which was also seen in IDA.

![](https://miro.medium.com/v2/resize:fit:659/1*RslTqTVco4_pf7z05lBMGw.png)

It will loop till the length of cipher text which is stored in edi register. And the eax register is the counter, which is compared with edi register to loop till length of cipher text. This is the for loop that was seen in IDA. The keystream generated from PRGA is XOR with cipher text, which output can be seen in dump below.

![](https://miro.medium.com/v2/resize:fit:700/1*R3blmJz_nKsz8vRZD-Tysg.png)

The cipher text ‘fVQMox8c’ after decoding from base64 and decrypting from rc4 was found to be ‘tlgrm_’.

<br>

Decrypting manually each of those cipher in this way will be time-consuming. So, config extractor can be written to automate these kinds of activities. I will publish the config extractor of this sample soon in my GitHub.

<br>

Stay tune for the next blog of this series to identify more encryption algorithms.
